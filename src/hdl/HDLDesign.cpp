#include "HDLDesign.hpp"
#include "HDLCoreDevices.hpp"
#include "Util.hpp"
#include <algorithm>
#include <set>
using namespace std;

namespace ElasticC {
namespace HDLGen {

HDLDesign::HDLDesign(string _name) : name(_name) {
  gnd = new HDLSignal("ecc_gnd", new LogicSignalPortType());
  vcc = new HDLSignal("ecc_vcc", new LogicSignalPortType());
  AddSignal(gnd);
  AddSignal(vcc);
  AddDevice(new ConstantHDLDevice(0, gnd));
  AddDevice(new ConstantHDLDevice(1, vcc));
}

void HDLDesign::AddSignal(HDLSignal *sig) { signals.push_back(sig); }

HDLSignal *HDLDesign::CreateTempSignal(HDLPortType *type, string prefix) {
  static int inc = 0;
  HDLSignal *sig = new HDLSignal(prefix + "_ecc_" + to_string(inc++), type);
  AddSignal(sig);
  return sig;
}

void HDLDesign::AddDevice(HDLDevice *dev) { devices.push_back(dev); }

void HDLDesign::AddPort(HDLDevicePort *port) {
  if (port->connectedNet != nullptr)
    if (find(signals.begin(), signals.end(), port->connectedNet) ==
        signals.end())
      signals.push_back(port->connectedNet);
  ports.push_back(port);
}

void HDLDesign::AddPortFromSig(HDLSignal *sig, PortDirection dir) {
  AddPort(new HDLDevicePort(sig->name, nullptr, sig->sigType, sig, dir));
}

void HDLDesign::RemoveDevice(HDLDevice *dev) {
  for (auto p : dev->GetPorts()) {
    if (p->connectedNet != nullptr) {
      auto p_fnd = find(p->connectedNet->connectedPorts.begin(),
                        p->connectedNet->connectedPorts.end(), p);
      if (p_fnd == p->connectedNet->connectedPorts.end())
        throw runtime_error("can't remove port as it does not exist in design");
      p->connectedNet->connectedPorts.erase(p_fnd);
    }
    p->connectedNet = nullptr;
  }
  auto dev_fnd = find(devices.begin(), devices.end(), dev);
  if (dev_fnd == devices.end())
    throw runtime_error("can't remove device ===" + dev->GetInstanceName() +
                        "=== as it does not exist in design");
  devices.erase(dev_fnd);
  delete dev;
}

void HDLDesign::RemoveSignal(HDLSignal *sig) {
  if (sig->connectedPorts.size() != 0)
    throw runtime_error("can't remove signal ===" + sig->name +
                        "=== as it still has connections to it");

  auto signal_fnd = find(signals.begin(), signals.end(), sig);
  if (signal_fnd == signals.end())
    throw runtime_error("can't remove signal ===" + sig->name +
                        "=== as it does not exist in design");
  signals.erase(signal_fnd);
  delete sig;
}

int HDLDesign::GetSignalFanout(HDLSignal *sig) {
  int fanout = 0;
  for (auto port : sig->connectedPorts) {
    // count device inputs and top level outputs
    if ((port->device != nullptr) && (port->dir == PortDirection::Input))
      fanout++;
    if ((port->device == nullptr) && (port->dir == PortDirection::Output))
      fanout++;
  }
  return fanout;
}

int HDLDesign::GetDeviceFanout(HDLDevice *dev) {
  int totalFanout = 0;
  for (auto port : dev->GetPorts()) {
    if ((port->connectedNet != nullptr) &&
        (port->dir == PortDirection::Output)) {
      totalFanout += GetSignalFanout(port->connectedNet);
    }
  }
  return totalFanout;
}

bool HDLDesign::PruneDevicesPass() {
  vector<HDLDevice *> toRemove;
  copy_if(devices.begin(), devices.end(), back_inserter(toRemove),
          [this](HDLDevice *d) { return GetDeviceFanout(d) == 0; });
  for_each(toRemove.begin(), toRemove.end(), [this](HDLDevice *d) {
    PrintMessage(MSG_DEBUG, "pruning device ===" + d->GetInstanceName() +
                                "=== as it has no connections");
    RemoveDevice(d);
  });
  return toRemove.size() > 0;
}

void HDLDesign::PruneNetsPass() {
  vector<HDLSignal *> toRemove;
  copy_if(signals.begin(), signals.end(), back_inserter(toRemove),
          [this](HDLSignal *s) { return s->connectedPorts.size() == 0; });
  for_each(toRemove.begin(), toRemove.end(), [this](HDLSignal *s) {
    PrintMessage(MSG_DEBUG, "pruning signal ===" + s->name +
                                "=== as it has no connections");
    RemoveSignal(s);
  });
}

void HDLDesign::Prune() {
  bool changed = false;
  do {
    changed = PruneDevicesPass();
    PruneNetsPass();
  } while (changed);
}

void HDLDesign::GenerateVHDLFile(ostream &out) {
  out << "--Generated by ElasticC version " << GetVersion() << endl << endl;
  set<string> deps;
  for (auto dev : devices) {
    auto ddeps = dev->GetVHDLDeps();
    deps.insert(ddeps.begin(), ddeps.end());
  }
  for (auto dep : deps) {
    string lib = dep.substr(0, dep.find('.'));
    out << "library " << lib << ";" << endl;
    out << "use " << dep << ";" << endl;
  }
  out << endl << endl;
  out << "entity " << name << " is " << endl;
  out << "\tport(" << endl;

  for (int i = 0; i < ports.size(); i++) {
    ports.at(i)->GenerateVHDL(out, (i == (ports.size() - 1)));
  }

  out << "\t);" << endl;
  out << "end " << name << ";" << endl << endl;

  out << "architecture hls_gen of " << name << " is" << endl;
  for (auto sig : signals) {
    if (find_if(ports.begin(), ports.end(), [this, sig](HDLDevicePort *p) {
          return (p->connectedNet == sig);
        }) == ports.end())
      sig->GenerateVHDL(out);
  }
  for (auto dev : devices)
    dev->GenerateVHDLPrefix(out);
  out << "begin" << endl;
  out << endl;
  for (auto dev : devices)
    dev->GenerateVHDL(out);
  out << "end hls_gen;" << endl;
};
} // namespace HDLGen
} // namespace ElasticC
